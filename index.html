<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Momo's PDF Cleaner Pro v2.4</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script>
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://unpkg.com/docx@7.1.0/build/index.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>

    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: '#6366f1',
                        secondary: '#ec4899',
                    }
                }
            }
        }
    </script>
    <style>
        /* --- 全局样式 --- */
        ::-webkit-scrollbar {
            width: 10px;
            height: 10px;
        }

        ::-webkit-scrollbar-track {
            background: #f1f1f1;
        }

        ::-webkit-scrollbar-thumb {
            background: #cbd5e1;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #94a3b8;
        }

        .pdf-page-container {
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1);
            margin-bottom: 2rem;
            background: white;
            position: relative;
        }

        .textLayer {
            position: absolute;
            text-align: initial;
            left: 0;
            top: 0;
            right: 0;
            bottom: 0;
            overflow: hidden;
            line-height: 1.0;
            opacity: 0.2;
            pointer-events: auto;
        }

        .textLayer ::selection {
            background: rgba(99, 102, 241, 0.4);
        }

        .textLayer span {
            color: transparent;
            position: absolute;
            white-space: pre;
            cursor: text;
            transform-origin: 0% 0%;
        }
    </style>
</head>

<body class="bg-gray-50 h-screen flex flex-col overflow-hidden text-gray-800">
    <div id="root" class="h-full flex flex-col"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback } = React;

        // --- Icons ---
        const IconUpload = () => <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4" /><polyline points="17 8 12 3 7 8" /><line x1="12" x2="12" y1="3" y2="15" /></svg>;
        const IconDownload = () => <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4" /><polyline points="7 10 12 15 17 10" /><line x1="12" x2="12" y1="15" y2="3" /></svg>;
        const IconFileWord = () => <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z" /><polyline points="14 2 14 8 20 8" /><line x1="16" x2="8" y1="13" y2="13" /><line x1="16" x2="8" y1="17" y2="17" /><line x1="10" x2="8" y1="9" y2="9" /></svg>;
        const IconBroom = () => <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M11.2 11.2a3 3 0 1 0 4.24 4.25l5.66-5.66a8 8 0 1 0-11.32-11.3l5.66 5.66z" /><path d="M6.3 16.5c-1.3 2.1-1.4 4.2-1.4 4.2a3 3 0 0 0 3 3c2.1 0 4.2 0 4.2-1.4" /></svg>;

        function App() {
            // --- State ---
            const [showCleaningPanel, setShowCleaningPanel] = useState(true);
            const [cleanStrings, setCleanStrings] = useState('');
            const [cleanPageRange, setCleanPageRange] = useState('');
            const [pdfFile, setPdfFile] = useState(null);
            const [pdfDoc, setPdfDoc] = useState(null);
            const [totalPages, setTotalPages] = useState(0);
            const [cleanedText, setCleanedText] = useState("");
            const [isProcessing, setIsProcessing] = useState(false);

            const fileInputRef = useRef(null);

            useEffect(() => {
                setCleanStrings(localStorage.getItem('im_clean_strings') || '');
                setCleanPageRange(localStorage.getItem('im_clean_range') || '');
            }, []);

            const triggerFileUpload = () => {
                if (fileInputRef.current) fileInputRef.current.click();
            };

            const handleFileUpload = async (event) => {
                const file = event.target.files[0];
                if (!file || file.type !== 'application/pdf') {
                    if (file) alert("目前仅支持 PDF 文件用于清洗。");
                    return;
                }
                setPdfFile(file);
                setCleanedText("");
                setIsProcessing(true);

                try {
                    const arrayBuffer = await file.arrayBuffer();
                    const loadingTask = pdfjsLib.getDocument(arrayBuffer);
                    const pdf = await loadingTask.promise;
                    setPdfDoc(pdf);
                    setTotalPages(pdf.numPages);

                    const rawText = await extractAllTextFromPdf(pdf);
                    const processed = applyRulesAndMerge(rawText);
                    setCleanedText(processed);
                    setIsProcessing(false);
                } catch (error) {
                    alert('PDF 解析失败: ' + error.message);
                    setIsProcessing(false);
                }
            };

            const extractAllTextFromPdf = async (pdf) => {
                let fullText = "";
                for (let i = 1; i <= pdf.numPages; i++) {
                    const page = await pdf.getPage(i);
                    const textContent = await page.getTextContent();
                    const items = textContent.items;
                    let pageText = "";
                    let lastY = -1;

                    for (let item of items) {
                        if (Math.abs(item.transform[5] - lastY) > 5) {
                            if (lastY !== -1) pageText += "\n";
                            lastY = item.transform[5];
                        }
                        pageText += item.str;
                    }
                    fullText += pageText + "\n";
                }
                return fullText;
            };

            const getPageNumbersToRemove = (rangeStr) => {
                if (!rangeStr) return new Set();
                const nums = new Set();
                const parts = rangeStr.split(/[,，]/);
                parts.forEach(part => {
                    part = part.trim();
                    if (part.includes('-')) {
                        const [start, end] = part.split('-').map(Number);
                        if (!isNaN(start) && !isNaN(end)) {
                            for (let i = start; i <= end; i++) nums.add(i);
                        }
                    } else {
                        const num = Number(part);
                        if (!isNaN(num)) nums.add(num);
                    }
                });
                return nums;
            };

            const smartParagraphMerge = (text) => {
                if (!text) return "";
                const bibRegex = /\n\s*(BIBLIOGRAPHY|REFERENCES|WORKS CITED)\s*\n/i;
                const match = text.match(bibRegex);
                let mainText = text;
                let bibText = "";
                let header = "";

                if (match) {
                    const index = match.index;
                    mainText = text.substring(0, index);
                    header = match[0].trim();
                    bibText = text.substring(index + match[0].length);
                }

                let cleanedMain = mainText;

                // 1. 连字符处理
                cleanedMain = cleanedMain.replace(/-\n+/g, ''); // Fix: 也支持连字符后跟多行空行的情况

                // 2. [关键修复] 标点处理：支持跨越多行合并
                // 只要不是结束标点，哪怕后面跟了 100 个换行符 (\n+)，也换成空格合并！
                // 这能解决“删除了页码/图片后留下的空行导致的断句”
                cleanedMain = cleanedMain.replace(/([^.\?!\:。？！：\)\"\'\u201d\u2019])\n+/g, '$1 ');

                // 3. 规范化空格 (变成单个空格)
                cleanedMain = cleanedMain.replace(/[ \t]+/g, ' ');

                // 4. 去除段首空格 (解决上一版引入的问题)
                cleanedMain = cleanedMain.replace(/\n[ \t]+/g, '\n');

                // 5. 将剩余的单换行转为双换行 (分段)
                // 此时剩下的 \n 都是真的段落结尾（因为有标点）
                cleanedMain = cleanedMain.replace(/\n+/g, '\n\n');

                let cleanedBib = "";
                if (bibText) {
                    let lines = bibText.split('\n').map(l => l.trim()).filter(l => l);
                    cleanedBib = lines.join('\n\n');
                }

                if (header) {
                    return cleanedMain.trim() + "\n\n" + header + "\n\n" + cleanedBib.trim();
                } else {
                    return cleanedMain.trim();
                }
            };

            const applyRulesAndMerge = (text) => {
                if (!text) return "";
                let cleaned = text;
                cleaned = cleaned.replace(/\r\n/g, "\n");

                const removeKeywords = cleanStrings.split(/[,，\n]/).map(s => s.trim()).filter(s => s);
                removeKeywords.forEach(keyword => {
                    if (keyword) cleaned = cleaned.split(keyword).join('');
                });

                const removePageNums = getPageNumbersToRemove(cleanPageRange);
                if (removePageNums.size > 0) {
                    const numPattern = new RegExp(`\\b(${Array.from(removePageNums).join('|')})\\b`, 'g');
                    cleaned = cleaned.replace(numPattern, '');
                }

                return smartParagraphMerge(cleaned);
            };

            const handleApplyCleaning = () => {
                localStorage.setItem('im_clean_strings', cleanStrings);
                localStorage.setItem('im_clean_range', cleanPageRange);
                const newText = applyRulesAndMerge(cleanedText);
                setCleanedText(newText);
            };

            const handleExportExcel = () => {
                if (!cleanedText) return;
                const paragraphs = cleanedText.split(/\n+/).filter(p => p.trim());
                const exportData = paragraphs.map(para => ({ "Content": para.trim() }));
                const ws = XLSX.utils.json_to_sheet(exportData);
                ws['!cols'] = [{ wch: 100 }];
                const wb = XLSX.utils.book_new();
                XLSX.utils.book_append_sheet(wb, ws, "CleanedText");
                XLSX.writeFile(wb, `Cleaned_Export_${new Date().toISOString().slice(0, 10)}.xlsx`);
            };

            const handleExportDocx = async () => {
                if (!cleanedText) return;
                const paragraphs = cleanedText.split(/\n+/).filter(p => p.trim());
                const docChildren = [];
                paragraphs.forEach((paraText, index) => {
                    docChildren.push(new docx.Paragraph({
                        children: [new docx.TextRun({ text: paraText, font: "Calibri", size: 26 })],
                        alignment: docx.AlignmentType.LEFT,
                        spacing: { after: 0, line: 240, lineRule: "auto" },
                    }));
                    if (index < paragraphs.length - 1) {
                        docChildren.push(new docx.Paragraph({ children: [], spacing: { after: 0, line: 240 } }));
                    }
                });
                const doc = new docx.Document({ sections: [{ children: docChildren }] });
                const blob = await docx.Packer.toBlob(doc);
                saveAs(blob, `Cleaned_Export_${new Date().toISOString().slice(0, 10)}.docx`);
            };

            return (
                <div className="flex flex-col h-full font-sans text-gray-800 relative overflow-hidden">
                    {/* Header */}
                    <header className="bg-white border-b border-gray-200 h-16 flex items-center justify-between px-6 shadow-sm z-10 shrink-0">
                        <div className="flex items-center gap-3">
                            <div className="bg-gradient-to-r from-primary to-secondary text-white w-8 h-8 rounded-lg flex items-center justify-center font-bold text-lg">M</div>
                            <h1 className="font-bold text-xl tracking-tight hidden md:block">Momo's PDF Cleaner Pro v2.4</h1>
                        </div>

                        <div className="flex items-center gap-3">
                            <button
                                onClick={triggerFileUpload}
                                className="flex items-center gap-2 px-4 py-2 bg-indigo-50 text-indigo-700 border border-indigo-200 rounded-lg hover:bg-indigo-100 transition font-medium text-sm"
                            >
                                <IconUpload /> 上传 PDF
                            </button>

                            <div className="w-px h-6 bg-gray-200 mx-1"></div>

                            <button onClick={() => setShowCleaningPanel(!showCleaningPanel)} className={`flex items-center gap-1 transition px-3 py-2 rounded-lg ${showCleaningPanel ? 'bg-gray-100 text-gray-800 font-bold' : 'text-gray-500 hover:bg-gray-50'}`}>
                                <IconBroom /> <span className="hidden sm:inline">规则</span>
                            </button>

                            <div className="flex gap-2">
                                <button onClick={handleExportExcel} disabled={!cleanedText} className="flex items-center gap-2 px-3 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 transition shadow-sm disabled:opacity-50 text-sm">
                                    <IconDownload /> Excel
                                </button>
                                <button onClick={handleExportDocx} disabled={!cleanedText} className="flex items-center gap-2 px-3 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition shadow-sm disabled:opacity-50 text-sm">
                                    <IconFileWord /> Word
                                </button>
                            </div>
                        </div>
                    </header>
                    <input type="file" ref={fileInputRef} className="hidden" accept=".pdf" onChange={handleFileUpload} />

                    {/* Cleaning Sidebar */}
                    <div className={`fixed right-0 top-16 bottom-0 w-80 bg-white shadow-2xl border-l border-gray-200 z-30 transform transition-transform duration-300 ease-in-out ${showCleaningPanel ? 'translate-x-0' : 'translate-x-full'}`}>
                        <div className="flex flex-col h-full p-6">
                            <div className="flex justify-between items-center mb-4">
                                <h3 className="font-bold text-gray-800 flex items-center gap-2"><IconBroom /> 清洗配置</h3>
                                <button onClick={() => setShowCleaningPanel(false)} className="text-gray-400 hover:text-gray-600">✕</button>
                            </div>

                            <div className="space-y-4 flex-1 overflow-y-auto">
                                <div>
                                    <label className="block text-sm font-bold text-gray-700 mb-2">去除包含文字</label>
                                    <textarea
                                        value={cleanStrings}
                                        onChange={(e) => setCleanStrings(e.target.value)}
                                        placeholder="粘贴页眉页脚的干扰文字..."
                                        className="w-full px-3 py-2 border border-gray-300 rounded-lg text-sm h-32 resize-none focus:ring-2 focus:ring-primary/20 outline-none"
                                    />
                                </div>
                                <div>
                                    <label className="block text-sm font-bold text-gray-700 mb-2">去除页码范围</label>
                                    <input
                                        type="text"
                                        value={cleanPageRange}
                                        onChange={(e) => setCleanPageRange(e.target.value)}
                                        placeholder="例如: 211-232"
                                        className="w-full px-3 py-2 border border-gray-300 rounded-lg text-sm outline-none focus:border-primary"
                                    />
                                </div>
                                <button
                                    onClick={handleApplyCleaning}
                                    className="w-full bg-primary text-white py-2.5 rounded-lg text-sm font-medium hover:bg-indigo-600 transition shadow-sm mt-4"
                                >
                                    应用清洗 & 智能合并
                                </button>
                            </div>
                        </div>
                    </div>

                    {/* Main Content Area */}
                    <main className={`flex-1 flex overflow-hidden transition-all duration-300 ease-in-out ${showCleaningPanel ? 'mr-80' : ''}`}>

                        {/* LEFT: PDF Viewer */}
                        <div className="w-1/2 bg-gray-100 border-r border-gray-200 flex flex-col relative">
                            <div className="h-10 bg-white border-b border-gray-200 flex items-center justify-between px-4 text-xs text-gray-500 font-medium shrink-0">
                                <span className="font-bold text-gray-700">PDF 原文 (可选中复制)</span>
                                <span>{pdfDoc ? `${totalPages} 页` : ''}</span>
                            </div>
                            <div className="flex-1 overflow-y-auto p-4 md:p-8 text-center scroll-smooth bg-gray-200/50 relative">
                                {!pdfDoc ? (
                                    <div className="h-full flex flex-col items-center justify-center text-gray-400 space-y-4">
                                        <p>点击右上角 "上传 PDF" 开始</p>
                                    </div>
                                ) : (
                                    <PdfRenderer pdfDoc={pdfDoc} />
                                )}
                                {isProcessing && (
                                    <div className="absolute inset-0 z-50 flex items-center justify-center bg-white/80 backdrop-blur-sm">
                                        <div className="flex flex-col items-center animate-pulse">
                                            <div className="w-8 h-8 border-4 border-primary border-t-transparent rounded-full animate-spin mb-2"></div>
                                            <span className="text-primary font-bold">正在处理全书...</span>
                                        </div>
                                    </div>
                                )}
                            </div>
                        </div>

                        {/* RIGHT: Cleaned Text */}
                        <div className="w-1/2 bg-white flex flex-col relative">
                            <div className="h-10 bg-white border-b border-gray-200 flex items-center justify-between px-4 text-xs text-gray-500 font-medium shrink-0">
                                <span className="font-bold text-gray-700">整理后文本</span>
                            </div>
                            <textarea
                                value={cleanedText}
                                onChange={(e) => setCleanedText(e.target.value)}
                                placeholder="结果显示区域..."
                                className="w-full h-full p-8 resize-none focus:outline-none text-gray-800 leading-relaxed text-lg"
                                style={{ fontFamily: 'Calibri, sans-serif' }}
                                spellCheck="false"
                            />
                        </div>
                    </main>
                </div>
            );
        }

        function PdfRenderer({ pdfDoc }) {
            const [pages, setPages] = useState([]);
            useEffect(() => {
                if (!pdfDoc) return;
                setPages(Array.from({ length: pdfDoc.numPages }, (_, i) => i + 1));
            }, [pdfDoc]);
            return <div className="flex flex-col items-center gap-6">{pages.map(p => <PdfPage key={p} pdfDoc={pdfDoc} pageNum={p} />)}</div>;
        }

        function PdfPage({ pdfDoc, pageNum }) {
            const canvasRef = useRef(null);
            const textLayerRef = useRef(null);
            const [scale, setScale] = useState(1.5);

            useEffect(() => {
                const renderPage = async () => {
                    const page = await pdfDoc.getPage(pageNum);
                    const viewport = page.getViewport({ scale });

                    const canvas = canvasRef.current;
                    const context = canvas.getContext('2d');
                    canvas.height = viewport.height;
                    canvas.width = viewport.width;

                    const renderContext = {
                        canvasContext: context,
                        viewport: viewport
                    };
                    await page.render(renderContext).promise;

                    const textContent = await page.getTextContent();
                    const textLayerDiv = textLayerRef.current;
                    textLayerDiv.innerHTML = "";
                    textLayerDiv.style.height = `${viewport.height}px`;
                    textLayerDiv.style.width = `${viewport.width}px`;

                    pdfjsLib.renderTextLayer({
                        textContent: textContent,
                        container: textLayerDiv,
                        viewport: viewport,
                        textDivs: []
                    });
                };
                renderPage();
            }, [pdfDoc, pageNum]);

            return (
                <div className="pdf-page-container" style={{ position: 'relative' }}>
                    <canvas ref={canvasRef} className="block" />
                    <div ref={textLayerRef} className="textLayer" />
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>

</html>